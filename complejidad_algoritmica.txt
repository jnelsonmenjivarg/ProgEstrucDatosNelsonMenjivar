import time
import random

# -----------------------------
# EJEMPLO DE COMPLEJIDAD
# -----------------------------

# Creamos una lista grande de números ordenados
lista = list(range(1, 1_000_000_000))

# Número objetivo
objetivo = random.choice(lista)

# -----------------------------
# BÚSQUEDA LINEAL - O(n) 
# -----------------------------
def busqueda_lineal(lista, objetivo):
    """Busca el número recorriendo todos los elementos."""
    for i in range(len(lista)):
        if lista[i] == objetivo:
            return i  # Devuelve la posición
    return -1  # Si no lo encuentra devolvemos -1

# -----------------------------
# BÚSQUEDA BINARIA - O(log n)
# -----------------------------
def busqueda_binaria(lista, objetivo):
    """Busca el número dividiendo la lista a la mitad en cada paso."""
    izquierda, derecha = 0, len(lista) - 1
    
    while izquierda <= derecha:
        medio = (izquierda + derecha) // 2
        if lista[medio] == objetivo:
            return medio
        elif lista[medio] < objetivo:
            izquierda = medio + 1
        else:
            derecha = medio - 1
    return -1

# -----------------------------
# COMPARACIÓN DE TIEMPOS
# -----------------------------
inicio = time.time()
busqueda_lineal(lista, objetivo)
fin = time.time()
print(f"El algoritmo de búsqueda lineal tardó: {fin - inicio:.10f} segundos")

inicio = time.time()
busqueda_binaria(lista, objetivo)
fin = time.time()
print(f"El algoritmo de búsqueda binaria tardó: {fin - inicio:.10f} segundos")

#Con mil millones estos fueron los resultados
#C:\Nelson\Programacion y Estructura de Datos> python .\complejidad_algoritmica.py
#El algoritmo de búsqueda lineal tardó: 119.6932590008 segundos
#El algoritmo de búsqueda binaria tardó: 0.0164048672 segundos


# Historico de subir a github
# PS C:\Nelson\Programacion y Estructura de Datos> git init
# Reinitialized existing Git repository in C:/Nelson/Programacion y Estructura de Datos/.git/
# Reinitialized existing Git repository in C:/Nelson/Programacion y Estructura de Datos/.git/
# PS C:\Nelson\Programacion y Estructura de Datos> giT add .\complejidad_algoritmica.py
# PS C:\Nelson\Programacion y Estructura de Datos> git commit -m "Commit complejidadalgoritmicat"
# [main b900a0d] Commit complejidadalgoritmicat
#  1 file changed, 52 insertions(+)
#  create mode 100644 complejidad_algoritmica.py
# PS C:\Nelson\Programacion y Estructura de Datos> git remote add origin https://github.com/jnelsonmenjivarg/ProgEstrucDatosNelsonMenjivar.git
# error: remote origin already exists.             git push -u origin main
# Enumerating objects: 4, done.structura de Datos>
# Counting objects: 100% (4/4), done.
# Delta compression using up to 20 threads
# Compressing objects: 100% (3/3), done.
# Writing objects: 100% (3/3), 894 bytes | 894.00 KiB/s, done.
# Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)
# To https://github.com/jnelsonmenjivarg/ProgEstrucDatosNelsonMenjivar.git
#    c4e1c5b..b900a0d  main -> main
# branch 'main' set up to track 'origin/main'.
# PS C:\Nelson\Programacion y Estructura de Datos> git push -f origin main
# Everything up-to-date
# PS C:\Nelson\Programacion y Estructura de Datos>

#Respuestas a preguntas
#P1. ¿Porqué el algoritmo de búsqueda binaria tiene una complejidad temporal más eficiente en 
#comparación con la búsqueda lineal?

#R1./La búsqueda binaria es más eficiente que la búsqueda lineal porque reduce drásticamente el número de comparaciones necesarias para encontrar un elemento. Esto se debe a que la búsqueda binaria descarta la mitad del conjunto de datos en cada paso, mientras que la búsqueda lineal revisa cada elemento uno por uno.
#La búsqueda lineal es un enfoque simple: comienza en el primer elemento de una lista y revisa cada uno de ellos en orden hasta que encuentra el elemento deseado o llega al final de la lista.
Peor escenario: Si el elemento que buscas está al final de la lista (o no está en ella), la búsqueda lineal tiene que revisar todos los elementos. Para una lista de n elementos, esto significa que realizará n comparaciones.
Complejidad temporal: Se expresa como O(n), lo que significa que el tiempo que tarda aumenta linealmente con el tamaño de la lista.
#La búsqueda binaria es más sofisticada y requiere que la lista esté ordenada.

#P2. ¿Qué condiciones debe tener la lista para que el algoritmo de búsqueda binaria haga su trabajo?
#R2. Para que el algoritmo de búsqueda binaria funcione correctamente y de manera eficiente, la lista o arreglo de 
#datos debe cumplir una condición fundamental e ineludible:
#La lista debe estar ordenada.
#Esta es la única condición estricta y absolutamente necesaria.

#P3: Si el número objetivo no se encuentra en la lista, ¿cómo se comportan ambos algoritmos en 
#cuanto a la cantidad de comparaciones realizadas y cuál resulta más costoso en términos de rendimiento?

#R3. Búsqueda secuencial (lineal):
#Recorre la lista elemento por elemento hasta encontrar el número objetivo o llegar al final.
#Si el número no está en la lista, siempre recorrerá todos los elementos.
#Comparaciones realizadas: En el peor caso (cuando no está) → n comparaciones (donde n es el tamaño de la lista).

#Búsqueda binaria:
#Solo funciona en listas ordenadas.
#Divide la lista a la mitad en cada paso, descartando la mitad que no contiene el objetivo.
#Si el número no está en la lista, sigue dividiendo hasta que no queden elementos por revisar.
#Comparaciones realizadas: En el peor caso (cuando no está) → alrededor de log₂(n) comparaciones.

Comparación en rendimiento cuando el número no está:
Lineal: hace n comparaciones.
Binaria: hace alrededor de log₂(n) comparaciones.